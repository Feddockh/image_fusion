Explain why my resulting rotation is always identity and my translation is always zero from the extrinsic compute function.

# Hayden Feddock
# 3/21/2025

import os
import sys
import cv2
import numpy as np
import glob
from typing import List, Dict
from scipy.optimize import least_squares


# Constants
CAMERA_NAMES = ["firefly_left", "firefly_right", "ximea", "zed_left", "zed_right"]
EXTENSION = ".png"
DEMOSAIC_MODE = True
CALIBRATION_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "calibration_files")


class Camera:
    def __init__(self, name: str):
        self.name = name
        self.camera_matrix: np.ndarray = np.zeros((3, 3), dtype=np.float32)
        self.dist_coeffs: np.ndarray = np.zeros((5,), dtype=np.float32)
        self.rectification_matrix: np.ndarray = np.eye(3, dtype=np.float32)
        self.projection_matrix: np.ndarray = np.zeros((3, 4), dtype=np.float32)
        self.width: int = 0
        self.height: int = 0

class MultiCamCapture:
    def __init__(self, cameras: List[Camera], image_set_dir: str):
        """
        Store the paths to the images for each camera used in a single capture.
        """
        self.cameras = cameras
        self.id = os.path.basename(image_set_dir)
        self.image_set_dir = image_set_dir
        self.image_paths: Dict[str, List[str]] = {
            cam.name: self.get_paths(cam.name) for cam in cameras
        }
        self.images: Dict[str, List[np.ndarray]] = {}

    def get_paths(self, camera_name: str) -> List[str]:
        """
        Get the paths to the images for a given camera.
        """
        # Check for the camera name in the image set dir and determine if it's a file or directory
        potential_file = os.path.join(self.image_set_dir, camera_name + EXTENSION)
        potential_dir = os.path.join(self.image_set_dir, camera_name)
        if os.path.isfile(potential_file):
            return [potential_file]
        elif os.path.isdir(potential_dir):
            return sorted(glob.glob(os.path.join(potential_dir, f"*{EXTENSION}")))
        else:
            return []
        
    def load_images(self) -> Dict[str, List[np.ndarray]]:
        """
        Load the images from the image paths.
        """
        for cam_name, paths in self.image_paths.items():
            self.images[cam_name] = [cv2.imread(path) for path in paths]
        return self.images
    
    def get_images(self, camera_name: str) -> List[np.ndarray]:
        """
        Get the images for a given camera.
        """
        return self.images[camera_name]

class MultiCamCalibration:
    def __init__(self, cameras: List[Camera], charuco_board: cv2.aruco.CharucoBoard):
        """
        Calibrate a multi-camera system using ChAruCo boards.
        """
        self.cameras = cameras
        self.charuco_board = charuco_board

        charuco_params = cv2.aruco.CharucoParameters()
        charuco_params.tryRefineMarkers = True
        detector_params = cv2.aruco.DetectorParameters()
        detector_params.adaptiveThreshConstant = 9
        detector_params.cornerRefinementMethod = cv2.aruco.CORNER_REFINE_SUBPIX
        refine_params = cv2.aruco.RefineParameters()
        
        self.charuco_detector = cv2.aruco.CharucoDetector(
            board=charuco_board,
            charucoParams=charuco_params,
            detectorParams=detector_params,
            refineParams=refine_params
        )

        self.captures: List[MultiCamCapture] = []

        # 2D image positions of detected ChArUco (chessboard) corners and marker corners
        self.all_charuco_corners: Dict[str, List[np.ndarray]] = {cam.name: [] for cam in cameras}
        self.all_charuco_ids: Dict[str, List[np.ndarray]] = {cam.name: [] for cam in cameras}
        self.all_marker_corners: Dict[str, List[np.ndarray]] = {cam.name: [] for cam in cameras}
        self.all_marker_ids: Dict[str, List[np.ndarray]] = {cam.name: [] for cam in cameras}

    def add_capture_dir(self, data_dir: str):
        for subdir in glob.glob(os.path.join(data_dir, "*")):
            if os.path.isdir(subdir):
                self.captures.append(MultiCamCapture(self.cameras, subdir))

    def detect_corners(self):
        """
        Detect the corners of the ChAruCo board for each camera in the multi-camera system.
        """

        # Loop through each capture set and detect the board and corners
        for capture in self.captures:

            # Load the images for each camera
            capture.load_images()
            
            # Detect the board and corners for each camera
            for cam in self.cameras:
                img = capture.get_images(cam.name)[0] # Just using the first image if there are multiple

                # Convert to grayscale if necessary
                if len(img.shape) == 3:
                    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

                # Set the camera width and height if they haven't been set
                if cam.width == 0 or cam.height == 0:
                    cam.height, cam.width = gray.shape[:2]

                # Get the corners and ids for the ChAruCo board and the marker corners and ids
                """
                charuco_corners   -> ndarray (N×1×2 float)   : 2D image positions of detected ChArUco (chessboard) corners  
                charuco_ids       -> ndarray (N×1 int)       : Unique IDs for each detected ChArUco corner  
                marker_corners    -> list of length M of 4×2 float arrays : Pixel coordinates of all detected ArUco marker corners  
                marker_ids        -> ndarray (M×1 int)       : IDs of detected ArUco markers (in same order as markerCorners)"
                """
                charuco_corners, charuco_ids, marker_corners, marker_ids = self.charuco_detector.detectBoard(gray)

                # Only store detections if enough corners were found
                if charuco_ids is not None and len(charuco_ids) > 0:
                    self.all_charuco_corners[cam.name].append(charuco_corners)
                    self.all_charuco_ids[cam.name].append(charuco_ids)
                    self.all_marker_corners[cam.name].append(marker_corners)
                    self.all_marker_ids[cam.name].append(marker_ids)

    def compute_intrinsics(self, camera: Camera):
        """
        Compute the intrinsics for a single camera.
        """
        # Skip cameras with no detections
        if len(self.all_charuco_corners[camera.name]) == 0:
            print(f"Warning: No detections for camera {camera.name}. Skipping calibration.")
            return

        # Calibrate the camera
        err, camera_matrix, dist_coeffs, rvecs, tvecs = cv2.aruco.calibrateCameraCharuco(
            charucoCorners=self.all_charuco_corners[camera.name],
            charucoIds=self.all_charuco_ids[camera.name],
            board=self.charuco_board,
            imageSize=(camera.width, camera.height),
            cameraMatrix=None,
            distCoeffs=None
        )

        return err, camera_matrix, dist_coeffs

    def compute_extrinsics(self, camera0: Camera, camera1: Camera):
        """
        Compute the extrinsics between two cameras using camera 0 as the reference.
        This function assumes that the cameras are already intrinsically calibrated and 
        that the object points and image points have been computed. We use the Levenberg-Marquardt
        algorithm to optimize the rotation and translation between the two cameras.
        """
        # Check for detections in both cameras
        if len(self.all_charuco_corners[camera0.name]) == 0 or len(self.all_charuco_corners[camera1.name]) == 0:
            print(f"Warning: No detections for cameras {camera0.name} and {camera1.name}. Skipping calibration.")
            return
        
        # Match the object points and image points for the two cameras across all captures
        capture_obj_pts = []
        capture_img_pts0 = []
        capture_img_pts1 = []
        for cam0_pts, cam0_ids, cam1_pts, cam1_ids in zip(self.all_charuco_corners[camera0.name], self.all_charuco_ids[camera0.name],
                                                          self.all_charuco_corners[camera1.name], self.all_charuco_ids[camera1.name]):

            # Match the object points (3D coordinates relative to the ChAruCo board) and image points (2D pixel coordinates)
            obj_pts0, img_pts0 = self.charuco_board.matchImagePoints(detectedCorners=cam0_pts, detectedIds=cam0_ids)
            obj_pts1, img_pts1 = self.charuco_board.matchImagePoints(detectedCorners=cam1_pts, detectedIds=cam1_ids)

            # Find the common object points and image points
            _, common_idx0, common_idx1 = np.intersect1d(cam0_ids, cam1_ids, return_indices=True)
            aligned_obj = obj_pts0[common_idx0]
            aligned_img0 = img_pts0[common_idx0]
            aligned_img1 = img_pts1[common_idx1]

            # Store the object points from this capture
            capture_obj_pts.append(aligned_obj)
            capture_img_pts0.append(aligned_img0)
            capture_img_pts1.append(aligned_img1)

        # Convert the object points and image points to numpy arrays
        all_obj_pts = np.vstack(capture_obj_pts)
        all_img_pts0 = np.vstack(capture_img_pts0)
        all_img_pts1 = np.vstack(capture_img_pts1)
        
        def residuals(x):
            # Extract the rotation and translation from the input vector
            r = x[:3]
            t = x[3:]
            R, _ = cv2.Rodrigues(r)

            # Project to camera0 (pose is identity)
            proj0, _ = cv2.projectPoints(
                objectPoints=all_obj_pts,
                rvec=np.zeros(3),
                tvec=np.zeros(3),
                cameraMatrix=camera0.camera_matrix,
                distCoeffs=camera0.dist_coeffs
            )
            proj0 = proj0.reshape(-1, 1, 2)

            # Project to camera1 (pose = R, t)
            proj1, _ = cv2.projectPoints(
                objectPoints=all_obj_pts,
                rvec=r,
                tvec=t,
                cameraMatrix=camera1.camera_matrix,
                distCoeffs=camera1.dist_coeffs
            )
            proj1 = proj1.reshape(-1, 1, 2)

            # Compute reprojection residuals
            res = np.concatenate([(proj0 - all_img_pts0).ravel(), (proj1 - all_img_pts1).ravel()])
            return res
        
        # Initial guess: identity rotation, zero translation
        rvec = np.zeros(3)
        tvec = np.zeros(3)
        x0 = np.hstack((rvec, tvec))

        # Optimize the rotation and translation between the two cameras
        result = least_squares(residuals, x0, method='lm')
        r_opt = result.x[:3]
        t_opt = result.x[3:]
        R_opt,_ = cv2.Rodrigues(r_opt)
        err = np.linalg.norm(result.fun) / result.fun.size
        return err, R_opt, t_opt.reshape(3,1)


def main():

    # # Retrieve folder containing the capture sets from input arguments
    # if len(sys.argv) < 2:
    #     print("Usage: python multi_cam_calibration.py <data_folder>")
    #     sys.exit(1)

    # data_dir = sys.argv[1]

    # # Expand the data folder path if it contains '~'
    # data_dir = os.path.expanduser(data_dir)
    data_dir = "/home/hayden/cmu/kantor_lab/ros2_ws/image_data"

    # Construct the camera objects
    firefly_left = Camera("firefly_left")
    firefly_right = Camera("firefly_right")
    ximea = Camera("ximea")
    zed_left = Camera("zed_left")
    zed_right = Camera("zed_right")
    cameras = [firefly_left, firefly_right, ximea, zed_left, zed_right]

    # Define the ChAruCo board parameters
    ARUCO_DICT = cv2.aruco.DICT_5X5_50
    SQUARES_VERTICALLY = 6
    SQUARES_HORIZONTALLY = 4
    SQUARE_LENGTH = 0.04
    MARKER_LENGTH = 0.03

    # Create the ChAruCo board
    dictionary = cv2.aruco.getPredefinedDictionary(ARUCO_DICT)
    charuco_board = cv2.aruco.CharucoBoard((SQUARES_VERTICALLY, SQUARES_HORIZONTALLY), SQUARE_LENGTH, MARKER_LENGTH, dictionary)

    # Create the multi-camera calibration object
    multi_cam_calib = MultiCamCalibration(cameras, charuco_board)
    multi_cam_calib.add_capture_dir(data_dir)

    # Calibrate the cameras
    multi_cam_calib.detect_corners()

    # Compute the intrinsics for each camera
    for cam in cameras:
        err, camera_matrix, dist_coeffs = multi_cam_calib.compute_intrinsics(cam)
        cam.camera_matrix = camera_matrix
        cam.dist_coeffs = dist_coeffs
        print(f"Camera {cam.name} intrinsics computed with error {err:.4f}.")

    # Compute the extrinsics between the ximea and firefly_left cameras
    err, R, t = multi_cam_calib.compute_extrinsics(ximea, firefly_left)
    print(f"Extrinsics between ximea and firefly_left computed with error {err:.4f}.")
    print(f"Rotation:\n{R}")
    print(f"Translation:\n{t}")


if __name__ == "__main__":
    main()
